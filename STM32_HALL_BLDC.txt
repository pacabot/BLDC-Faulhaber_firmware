/*
 * STM32_HALL_BLDC.c
 *
 *  Created on: 1 janv. 2018
 *      Author: zhonx

Interfacing with Hall sensors
This is done using the advanced-control timers (TIM1 or TIM8) to generate PWM signals to
drive the motor and another timer TIMx (TIM2, TIM3, TIM4 or TIM5) referred to as
“interfacing timer” in Figure 129. The “interfacing timer” captures the 3 timer input pins
(TIMx_CH1, TIMx_CH2, and TIMx_CH3) connected through a XOR to the TI1 input channel
(selected by setting the TI1S bit in the TIMx_CR2 register).
The slave mode controller is configured in reset mode; the slave input is TI1F_ED. Thus,
each time one of the 3 inputs toggles, the counter restarts counting from 0. This creates a
time base triggered by any change on the Hall inputs.
On the “interfacing timer”, capture/compare channel 1 is configured in capture mode,
capture signal is TRC (see Figure 112). The captured value, which corresponds to the time
elapsed between 2 changes on the inputs, gives information about motor speed.
The “interfacing timer” can be used in output mode to generate a pulse which changes the
configuration of the channels of the advanced-control timer (TIM1 or TIM8) (by triggering a
COM event). The TIM1 timer is used to generate PWM signals to drive the motor. To do this,
the interfacing timer channel must be programmed so that a positive pulse is generated
after a programmed delay (in output compare or PWM mode). This pulse is sent to the
advanced-control timer (TIM1 or TIM8) through the TRGO output.
Example: the user wants to change the PWM configuration of the advanced-control timer
TIM1 after a programmed delay each time a change occurs on the Hall inputs connected to
one of the TIMx timers.
• Configure 3 timer inputs ORed to the TI1 input channel by writing the TI1S bit in the
TIMx_CR2 register to ‘1’,
• Program the time base: write the TIMx_ARR to the max value (the counter must be
cleared by the TI1 change. Set the prescaler to get a maximum counter period longer
than the time between 2 changes on the sensors,
• Program channel 1 in capture mode (TRC selected): write the CC1S bits in the
TIMx_CCMR1 register to ‘11’. The user can also program the digital filter if needed,
• Program channel 2 in PWM 2 mode with the desired delay: write the OC2M bits to ‘111’
and the CC2S bits to ‘00’ in the TIMx_CCMR1 register,
• Select OC2REF as trigger output on TRGO: write the MMS bits in the TIMx_CR2
register to ‘101’,
In the advanced-control timer TIM1, the right ITR input must be selected as trigger input, the
timer is programmed to generate PWM signals, the capture/compare control signals are
preloaded (CCPC=1 in the TIMx_CR2 register) and the COM event is controlled by the
trigger input (CCUS=1 in the TIMx_CR2 register). The PWM control bits (CCxE, OCxM) are
written after a COM event for the next step (this can be done in an interrupt subroutine
generated by the rising edge of OC2REF).

 */

/*STM32 BLDC Control with HALL Sensor

The code is not a complete project, it's to show you how to use the motor timer to control an BLDC Motor in combination with an HALL Sensor on another timer.
Inhaltsverzeichnis

    1 Intro
    2 Code for the HallSensor timer
    3 Code for BLDC motor control timer
    4 Some things good to know
    5 Footnotes

Intro

The system needs two timers. One to control PWM for the bridge FETs and another timer to identify the HallSensor singnals. The HallSensor timer triggers the motor timer commutation event.

The connection betwenn these two timers is done in the background with events. There is no direct need for interrupt handling to commutate the motor timer.

    BLDC Bridge FETs: TIM1
    HallSensor: TIM4

Recommendation: For your first projects and to learn more, I suggest to use a protection 3 phase motor driver. In there documents you find good information about shoot-through protection, on-time, off-time, dead-time, hall-steps, rpm and field frequency, cutoff filter frequency and many more. Some of the chips offers also simplified usage of sensorless motor control because they detect the rotorposition and give back a virtual Hall Signal, see the TMC product.

    Allegro A4935 [1]
    TMC 603 [2]

If you have a simple FET bridge driver then you must carfully calculate the dead time which is a prameter in the motortimer.

Active Freewheeling
    Without active freewheeling the body diodes during PWM OFF time produce a huge amount of power loss. With active freewheeling this power loss can be reduced.

Info
    Check HallSensor Inputs. They often needs PullUps, use RC filters to filter bad signals.

Code for the HallSensor timer

Internal Connection from Hall/Enc Timer to Motor Timer. The HALL Timer Output is direct connected to the Motor Timer Commutation Trigger. If the correct combination of Motor and Hall/Enc Timer is selected then this is done for you. If you can not use the internal Connection you have to do this in an Interrupt manually.

Only following Combinations are possible[1]

If Motor is on Timer1 this is possible

    Hall/Enc is Timer 2 → Motor is Timer 1 → use TIM_TS_ITR1
    Hall/Enc is Timer 3 → Motor is Timer 1 → use TIM_TS_ITR2
    Hall/Enc is Timer 4 → Motor is Timer 1 → use TIM_TS_ITR3
    Hall/Enc is Timer 5 → Motor is Timer 1 → use TIM_TS_ITR0

If Motor is on Timer8 this is possible

    Hall/Enc is Timer 1 → Motor is Timer 8 → use TIM_TS_ITR0
    Hall/Enc is Timer 2 → Motor is Timer 8 → use TIM_TS_ITR1
    Hall/Enc is Timer 4 → Motor is Timer 8 → use TIM_TS_ITR2
    Hall/Enc is Timer 5 → Motor is Timer 8 → use TIM_TS_ITR3
*/

void configHallSensorTimer(void) {

// Timer 3 decodes the 3 HallSensor input lines
// see referenze manual page 305

// define timer clock
// between two changes on the hall sensor lines on the lowest rotation
// speed (eg. 1/100 from max. speed)  the timer must not overflow
// define timer counter clock appropriate

// enable port pins for hall inputs
RCC_APB2PeriphClockCmd(...);
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_...;
GPIO_InitStructure.GPIO_Mode = ...
GPIO_Init(..., &GPIO_InitStructure);

RCC_APB1PeriphClockCmd(TIM4_CLK, ENABLE);

  // timer base configuration
  // 126 => 3,5s till overflow ; 285,714kHz TimerClock [36MHz/Prescaler]
  TIM_TimeBaseStructure.TIM_Prescaler = 126;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseStructure.TIM_Period = 65535;
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
  TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);

  // enable hall sensor
  // T1F_ED will be connected to  HallSensoren Imputs
  // TIM4_CH1,TIM4_CH2,TIM4_CH3
  TIM_SelectHallSensor(TIM4, ENABLE);

  //  TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
  //  uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)

  // HallSensor event is delivered with singnal TI1F_ED
  // (this is XOR of the three hall sensor lines)
  // Signal TI1F_ED: falling and rising ddge of the inputs is used
  TIM_SelectInputTrigger(TIM4, TIM_TS_TI1F_ED);

  // On every TI1F_ED event the counter is resetted and update is tiggered
  TIM_SelectSlaveMode(TIM4, TIM_SlaveMode_Reset);

  // Channel 1 in input capture mode
  // on every TCR edge (build from TI1F_ED which is a HallSensor edge)
  // the timervalue is copied into ccr register and a CCR1 Interrupt
  // TIM_IT_CC1 is fired

  TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
  TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;
  // listen to T1, the  HallSensorEvent
  TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_TRC;
  // Div:1, every edge
  TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
  // noise filter: 1111 => 72000kHz / factor (==1) / 32 / 8 -> 281kHz
  // input noise filter (reference manual page 322)
  TIM_ICInitStructure.TIM_ICFilter = 0xF;
  TIM_ICInit(TIM4, &TIM_ICInitStructure);

  // channel 2 can be use for commution delay between hallsensor edge
  // and switching the FET into the next step. if this delay time is
  // over the channel 2 generates the commutation signal to the motor timer
  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;
  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
  TIM_OCInitStructure.TIM_Pulse = 1; // 1 is no delay; 2000 = 7ms
  TIM_OC2Init(TIM4, &TIM_OCInitStructure);

  // clear interrupt flag
  TIM_ClearFlag(TIM4, TIM_FLAG_CC2);

  //TIM_SelectMasterSlaveMode(TIM4, TIM_MasterSlaveMode_Enable);
  // TIM_SelectOutputTrigger(TIM4, TIM_TRGOSource_OC1);
  // timer2 output compate signal is connected to TRIGO
  TIM_SelectOutputTrigger(TIM4, TIM_TRGOSource_OC2Ref);

  // Enable channel 2 compate interrupt request
  // TIM_IT_CC1 | TIM_IT_CC2
  TIM_ITConfig(TIM4, TIM_IT_CC1 | TIM_IT_CC2, ENABLE);

  // Enable output compare preload
  //TIM_OC4PreloadConfig(TIM4, TIM_OCPreload_Enable);

  // Enable ARR preload
  //TIM_ARRPreloadConfig(TIM4, ENABLE);

  // Enable update event
  //TIM_ClearFlag(TIM4, TIM_FLAG_Update);
  //TIM_ITConfig(TIM4, TIM_IT_Update, DISABLE);

  // we use preemption interrupts here,  BLDC Bridge switching and
  // Hall has highest priority
  NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  NVIC_Init(&NVIC_InitStructure);

  // -------------------
  // HallSensor is now configured, if BLDC Timer is also configured
  // after enabling timer 4
  // the motor will start after next overflow of the hall timer because
  // this generates the first startup motor cummutation event
  TIM_Cmd(TIM4, ENABLE);
}

void incCommutationDelay(void) {
  TIM4->CCR2 = (TIM4->CCR2) + 1;
}

void decCommutationDelay(void) {
  TIM4->CCR2 = (TIM4->CCR2) - 1;
}

// ------------- HallSensor interrupt handler -----------------

// this handles TIM4 irqs (from HallSensor)
void TIM4_IRQHandler(void) {
  if (TIM_GetITStatus(TIM4, TIM_IT_CC1) != RESET)
  {
    TIM_ClearITPendingBit(MOTOR_TMC603_HALLENC_TIM, TIM_IT_CC1);
    // calculate motor  speed or else with CCR1 values
    hallccr1 = TIM4->CCR1;
    ...
  }
  else if (TIM_GetITStatus(TIM4, TIM_IT_CC2) != RESET)
  {
    TIM_ClearITPendingBit(MOTOR_TMC603_HALLENC_TIM, TIM_IT_CC2);
    // this interrupt handler is called AFTER the motor commutaton event
    // is done
    // after commutation the next motor step must be prepared
    // use inline functions in irq handlers static __INLINE funct(..) {..}
    BLDCMotorPrepareCommutation();
  } else {
    ; // this should not happen
  }
}

Code for BLDC motor control timer

void configMotorBridgeTimer(void) {

// define timer clock, motor timer can be TIM1 or TIM8
RCC_APB2PeriphClockCmd(...);

// define the 6 output pins for the bridge, if needed define
// the input pin for emergeny stop

// Chopper Frequency (PWM for the FETs)
// 18kHz was good in empiric tests
// ARR = SystemCoreClock / ChopperFreq
// ARR defines also the resolution of the Chopper PWM
#define BLDC_CHOPPER_PERIOD ((uint16_t)4000)

  // Time Base configuration

  TIM_TimeBaseStructure.TIM_Prescaler = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseStructure.TIM_Period = BLDC_CHOPPER_PERIOD;
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
  TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);

  // Channel 1, 2, 3 – set to PWM mode - all 6 outputs
  // per channel on output is  low side fet, the opposite is for high side fet

  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
  TIM_OCInitStructure.TIM_Pulse = 0; // BLDC_ccr_val

  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
  TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
  TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
  TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Set;

  TIM_OC1Init(TIM1, &TIM_OCInitStructure);
  TIM_OC2Init(TIM1, &TIM_OCInitStructure);
  TIM_OC3Init(TIM1, &TIM_OCInitStructure);

  // activate preloading the CCR register
  TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
  TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);
  TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);

  /* automatic output enable, break off, dead time ca. 200ns and

  // no lock of configuration */

  TIM_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
  TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
  TIM_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_OFF;

  // DeadTime value n=1 bis 31: from 14ns to 1,7us
  // DeadTime value n=129 bis 159: from 1,7µs to 3,5ms
  // DeadTime value 7 => 98ns
  // ... see programmers reference manual

  // DeadTime[ns] = value * (1/SystemCoreFreq) (on 72MHz: 7 is 98ns)
  TIM_BDTRInitStructure.TIM_DeadTime = 7; // 98ns

  TIM_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Enable;

  // enabel this if you use emergency stop signal
  // TIM_BDTRInitStructure.TIM_Break = TIM_Break_Enable;
  // TIM_BDTRInitStructure.TIM_BreakPolarity = MOTOR_TMC603_EMSTOP_POLARITY;

  TIM_BDTRInitStructure.TIM_Break = TIM_Break_Disable;

  TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);

  // preload ARR register
  TIM_CCPreloadControl(TIM1, ENABLE);

  // activate COM (Commutation) Event from Slave (HallSensor timer)
  // through TRGI
  enableHallCommutateSignal();

  // Internal connection from Hall/Enc Timer to Motor Timer
  // eg. TIM1 (BLDC Motor Timer) is Slave of TIM3 (Hall Timer)
  // Internal connection from Hall/Enc Timer to Motor Timer

  // Choose carefully from the following possible combination
  // check programmers reference manual
  // TIM_SelectInputTrigger(TIM1, TIM_TS_ITR0);
  // MotorTimer = TIM1, HallTimer = TIM5
  // TIM_SelectInputTrigger(TIM1, TIM_TS_ITR1);
  // MotorTimer = TIM1, HallTimer = TIM2
  // TIM_SelectInputTrigger(TIM1, TIM_TS_ITR2);
  // MotorTimer = TIM1, HallTimer = TIM3
 TIM_SelectInputTrigger(TIM1, TIM_TS_ITR3);
  // MotorTimer = TIM1, HallTimer = TIM4
  // TIM_SelectInputTrigger(TIM8, TIM_TS_ITR0);
  // MotorTimer = TIM8, HallTimer = TIM1
  // TIM_SelectInputTrigger(TIM8, TIM_TS_ITR1);
  // MotorTimer = TIM8, HallTimer = TIM2
  // TIM_SelectInputTrigger(TIM8, TIM_TS_ITR2);
  // MotorTimer = TIM8, HallTimer = TIM4
  // TIM_SelectInputTrigger(TIM8, TIM_TS_ITR3);
  // MotorTimer = TIM8, HallTimer = TIM5

  // Enable interrupt, motor commutation has high piority and has
  // a higher subpriority then the hall sensor
  NVIC_InitStructure.NVIC_IRQChannel = TIM1_TRG_COM_IRQn;

  // highest priority
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;

  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  // highest priority
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

  NVIC_Init(&NVIC_InitStructure);

  // Interrupt for hardwired EmergencyStop
 (if needed)
  // Timer 1 Motor Emergency Break Input
  // NVIC_InitStructure.NVIC_IRQChannel = TIM1_BRK_IRQn;
  // NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
  // NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  // NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  // NVIC_Init(&NVIC_InitStructure);

  // --------- activate the bldc bridge ctrl. ----------
  // in a project this will be done late after complete
  // configuration of other peripherie

  // enable COM (commutation) IRQ
  TIM_ITConfig(TIM1, TIM_IT_COM, ENABLE);

  // enable motor timer
  TIM_Cmd(TIM1, ENABLE);

  // enable motor timer main output (the bridge signals)
  TIM_CtrlPWMOutputs(TIM1, ENABLE);
}

// enable the connection between HallTimer and MotorTimer
void enableHallCommutateSignal() {
   TIM_SelectCOM(TIM1, ENABLE);
}

// disable the connection between HallTimer and MotorTimer
void disableHallCommutateSignal() {
   TIM_SelectCOM(TIM1, DISABLE);
}

// BLDC motor steps
// every row from 1 to 6 is called by a hall state
// every column a FET from 3-phase bridge
// motor off is at row 0 BLDC_BRIDGE_STATE_VORWARD[0]
// cw - rechtslauf - positiv
// {    1H,1L      ,      2H,2L      ,     3H,3L    }
// BLDC motor steps
// every row from 1 to 6 is one of the 6 motor vector state
// every column a FET from 3-phase bridge
// all FETs off at row 0 or 8 (this pattern should not come from the hallsensor)
// cw - rechtslauf - positiv
// {    1H,1L      ,      2H,2L      ,     3H,3L    }
static const uint8_t BLDC_BRIDGE_STATE_VORWARD[8][6] =   // Motor step
{
   { FALSE,FALSE   ,   FALSE,FALSE   ,  FALSE,FALSE },  // 0
   { FALSE,TRUE    ,   TRUE ,FALSE   ,  FALSE,FALSE },  // 2
   { FALSE,FALSE   ,   FALSE,TRUE    ,  TRUE ,FALSE },  // 4
   { FALSE,TRUE    ,   FALSE,FALSE   ,  TRUE ,FALSE },  // 3
   { TRUE ,FALSE   ,   FALSE,FALSE   ,  FALSE,TRUE  }   // 6
   { FALSE,FALSE   ,   TRUE ,FALSE   ,  FALSE,TRUE  },  // 1
   { TRUE ,FALSE   ,   FALSE,TRUE    ,  FALSE,FALSE },  // 5
   { FALSE,FALSE   ,   FALSE,FALSE   ,  FALSE,FALSE },  // 0
};

// This function handles motor timer trigger and commutation interrupts
// can be used for calculation...
void TIM1_TRG_COM_IRQHandler(void)
{
  TIM_ClearITPendingBit(TIM1, TIM_IT_COM);
  // commutationCount++;
}

/* This is called from HALL timer interrupt handler
   remember:
     if hall a hall edge is detected
     first the motor commutation event is done
     next this routine is called which has to prepare the next motor step
     (which FET must be switched on or off)
   active freewhelling is used to minimize power loss

   code should be easy to understand and to debug... for practical use
   you should optimize it */

static __INLINE void BLDCMotorPrepareCommutation(void)
{
  // next bridge step calculated by HallSensor inputs
  // if there was an hall event without changing the hall position,
  // do nothing.
  //
  // In principle, on every hall event you can go to the next motor
  // step but i had sometimes problems that the motor was running
  // on an harmonic wave (??) when the motor was without load
  uint16_t newhallpos = ((GPIO_ReadInputData(GPIOD) & 0x7000) >> 12);

  if (newhallpos == hallpos) return;
  lasthallpos = hallpos;

  hallpos = newhallpos;

  // this is only for motor direction forward

  BH1 = BLDC_BRIDGE_STATE_VORWARD[hallpos][0];
  BL1 = BLDC_BRIDGE_STATE_VORWARD[hallpos][1];

  BH2 = BLDC_BRIDGE_STATE_VORWARD[hallpos][2];
  BL2 = BLDC_BRIDGE_STATE_VORWARD[hallpos][3];

  BH3 = BLDC_BRIDGE_STATE_VORWARD[hallpos][4];
  BL3 = BLDC_BRIDGE_STATE_VORWARD[hallpos][5];

  // **** this is with active freewheeling ****

  // Bridge FETs for Motor Phase U
  if (BH1) {

    // PWM at low side FET of bridge U
    // active freewheeling at high side FET of bridge U
    // if low side FET is in PWM off mode then the hide side FET
    // is ON for active freewheeling. This mode needs correct definition
    // of dead time otherwise we have shoot-through problems

    TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_PWM1);

    TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);

    TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Enable);

  } else {

    // Low side FET: OFF
    TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Disable);

    if (BL1){

     // High side FET: ON
     TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_ForcedAction_Active);

      TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Enable);

    } else {

      // High side FET: OFF
      TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);

    }

  }

  // Bridge FETs for Motor Phase V

  if (BH2) {
    TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_PWM1);
    TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
    TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Enable);
  } else {
    TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Disable);

    if (BL2){
      TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_ForcedAction_Active);
      TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Enable);
    } else {
      TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
    }
  }

  // Bridge FETs for Motor Phase W

  if (BH3) {
    TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_PWM1);
    TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
    TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Enable);
  } else {
    TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Disable);

  if (BL3){
      TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_ForcedAction_Active);
      TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Enable);
    } else {
      TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
    }
  }
}

Some things good to know

// You can manually generate an commutation event (like the hall sensor)
TIM_GenerateEvent(TIM1, TIM_EventSource_COM);

// how to change the PWM value
TIM1->CCR1 = new_ccr_val;
TIM1->CCR2 = new_ccr_val;
TIM1->CCR3 = new_ccr_val;

Footnotes

Check STM32 Reference Manual for Internal Trigger 1 to 4 (ITR1 to ITR4). See Table "TIMx Internal trigger connection".







































#include "stm32f4xx.h"
#include "stm32f4xx_rcc.h"
#include "stm32f4xx_tim.h"
#include "misc.h"
#include "stm32f4xx_gpio.h"
#include <stdbool.h>

void enableHallCommutateSignal();

void configMotorBridgeTimer(void)
{
    TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
    TIM_OCInitTypeDef TIM_OCInitStructure;
    TIM_BDTRInitTypeDef TIM_BDTRInitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;
    GPIO_InitTypeDef GPIO_InitStructure;

    // define timer clock, motor timer can be TIM1 or TIM8
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);


    // define the 6 output pins for the bridge, if needed define
    // the input pin for emergeny stop
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE);
    GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
    GPIO_Init(GPIOE, &GPIO_InitStructure);

    GPIO_PinAFConfig(GPIOE, GPIO_PinSource8, GPIO_AF_TIM1);
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource9, GPIO_AF_TIM1);
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource10, GPIO_AF_TIM1);
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource11, GPIO_AF_TIM1);
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource12, GPIO_AF_TIM1);
    GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_TIM1);


    // Chopper Frequency (PWM for the FETs)
    // 18kHz was good in empiric tests
    // ARR = SystemCoreClock / ChopperFreq
    // ARR defines also the resolution of the Chopper PWM
    #define BLDC_CHOPPER_PERIOD ((uint16_t)4000)

  // Time Base configuration

  TIM_TimeBaseStructure.TIM_Prescaler = 0;
  TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
  TIM_TimeBaseStructure.TIM_Period = BLDC_CHOPPER_PERIOD;
  TIM_TimeBaseStructure.TIM_ClockDivision = 0;
  TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
  TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);

  // Channel 1, 2, 3 – set to PWM mode - all 6 outputs
  // per channel on output is  low side fet, the opposite is for high side fet

  TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
  TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
  TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
  TIM_OCInitStructure.TIM_Pulse = 0; // BLDC_ccr_val

  TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;     //High, stimmt
  TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;   //High, stimmt
  TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Reset;  //Set
  TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCNIdleState_Reset;    //Set

  TIM_OC1Init(TIM1, &TIM_OCInitStructure);
  TIM_OC2Init(TIM1, &TIM_OCInitStructure);
  TIM_OC3Init(TIM1, &TIM_OCInitStructure);

  // activate preloading the CCR register
  TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
  TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable);
  TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable);

  /* automatic output enable, break off, dead time ca. 200ns and

  // no lock of configuration */

  TIM_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;
  TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;
  TIM_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_OFF;

  // DeadTime value n=1 bis 31: from 6ns to 185ns
  // DeadTime value n=129 bis 159: from 767ns to 946ns
  // DeadTime value 7 => 42ns
  // ... see programmers reference manual

  // DeadTime[ns] = value * (1/SystemCoreFreq) (on 168MHz: 18 is 107ns) -> hier 168MHz
  TIM_BDTRInitStructure.TIM_DeadTime = 18; // 107ns

  TIM_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Enable;

  // enabel this if you use emergency stop signal
  // TIM_BDTRInitStructure.TIM_Break = TIM_Break_Enable;
  // TIM_BDTRInitStructure.TIM_BreakPolarity = MOTOR_TMC603_EMSTOP_POLARITY;

  TIM_BDTRInitStructure.TIM_Break = TIM_Break_Disable;

  TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);

  // preload ARR register
  TIM_CCPreloadControl(TIM1, ENABLE);

  // activate COM (Commutation) Event from Slave (HallSensor timer)
  // through TRGI
  enableHallCommutateSignal();

  // Internal connection from Hall/Enc Timer to Motor Timer
  // eg. TIM1 (BLDC Motor Timer) is Slave of TIM3 (Hall Timer)
  // Internal connection from Hall/Enc Timer to Motor Timer

  // Choose carefully from the following possible combination
  // check programmers reference manual
  // TIM_SelectInputTrigger(TIM1, TIM_TS_ITR0);
  // MotorTimer = TIM1, HallTimer = TIM5
  // TIM_SelectInputTrigger(TIM1, TIM_TS_ITR1);
  // MotorTimer = TIM1, HallTimer = TIM2
  TIM_SelectInputTrigger(TIM1, TIM_TS_ITR2);
  // MotorTimer = TIM1, HallTimer = TIM3
 // TIM_SelectInputTrigger(TIM1, TIM_TS_ITR3);
  // MotorTimer = TIM1, HallTimer = TIM4
  // TIM_SelectInputTrigger(TIM8, TIM_TS_ITR0);
  // MotorTimer = TIM8, HallTimer = TIM1
  // TIM_SelectInputTrigger(TIM8, TIM_TS_ITR1);
  // MotorTimer = TIM8, HallTimer = TIM2
  // TIM_SelectInputTrigger(TIM8, TIM_TS_ITR2);
  // MotorTimer = TIM8, HallTimer = TIM4
  // TIM_SelectInputTrigger(TIM8, TIM_TS_ITR3);
  // MotorTimer = TIM8, HallTimer = TIM5

  // Enable interrupt, motor commutation has high piority and has
  // a higher subpriority then the hall sensor
  NVIC_InitStructure.NVIC_IRQChannel = TIM1_TRG_COM_TIM11_IRQn;

  // highest priority
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;

  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  // highest priority
  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;

  NVIC_Init(&NVIC_InitStructure);

  // Interrupt for hardwired EmergencyStop
 //(if needed)
  // Timer 1 Motor Emergency Break Input
  // NVIC_InitStructure.NVIC_IRQChannel = TIM1_BRK_IRQn;
  // NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x00;
  // NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
  // NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
  // NVIC_Init(&NVIC_InitStructure);

  // --------- activate the bldc bridge ctrl. ----------
  // in a project this will be done late after complete
  // configuration of other peripherie

  // enable COM (commutation) IRQ
  TIM_ITConfig(TIM1, TIM_IT_COM, ENABLE);

  // enable motor timer
  TIM_Cmd(TIM1, ENABLE);

  // enable motor timer main output (the bridge signals)
  TIM_CtrlPWMOutputs(TIM1, ENABLE);
}

// enable the connection between HallTimer and MotorTimer
void enableHallCommutateSignal() {
   TIM_SelectCOM(TIM1, ENABLE);
}

// disable the connection between HallTimer and MotorTimer
void disableHallCommutateSignal() {
   TIM_SelectCOM(TIM1, DISABLE);
}

// BLDC motor steps
// every row from 1 to 6 is called by a hall state
// every column a FET from 3-phase bridge
// motor off is at row 0 BLDC_BRIDGE_STATE_VORWARD[0]
// cw - rechtslauf - positiv
// {    1H,1L      ,      2H,2L      ,     3H,3L    }
// BLDC motor steps
// every row from 1 to 6 is one of the 6 motor vector state
// every column a FET from 3-phase bridge
// all FETs off at row 0 or 8 (this pattern should not come from the hallsensor)
// cw - rechtslauf - positiv
// {    1H,1L      ,      2H,2L      ,     3H,3L    }
static const uint8_t BLDC_BRIDGE_STATE_VORWARD[8][6] =  // Motor step
{
   { false,false   ,   false,false   ,  false,false },  // 0
   { false,true    ,   true ,false   ,  false,false },  // 2
   { false,false   ,   false,true    ,  true ,false },  // 4
   { false,true    ,   false,false   ,  true ,false },  // 3
   { true ,false   ,   false,false   ,  false,true  },  // 6
   { false,false   ,   true ,false   ,  false,true  },  // 1
   { true ,false   ,   false,true    ,  false,false },  // 5
   { false,false   ,   false,false   ,  false,false },  // 0
};

// This function handles motor timer trigger and commutation interrupts
// can be used for calculation...
//void TIM1_TRG_COM_IRQHandler(void)
void TIM1_TRG_COM_TIM11_IRQHandler(void)
{
  TIM_ClearITPendingBit(TIM1, TIM_IT_COM);
  // commutationCount++;
}

/* This is called from HALL timer interrupt handler
   remember:
     if hall a hall edge is detected
     first the motor commutation event is done
     next this routine is called which has to prepare the next motor step
     (which FET must be switched on or off)
   active freewhelling is used to minimize power loss

   code should be easy to understand and to debug... for practical use
   you should optimize it */

//static __INLINE void BLDCMotorPrepareCommutation(void)
inline void BLDCMotorPrepareCommutation(void)
{
  // next bridge step calculated by HallSensor inputs
  // if there was an hall event without changing the hall position,
  // do nothing.
  //
  // In principle, on every hall event you can go to the next motor
  // step but i had sometimes problems that the motor was running
  // on an harmonic wave (??) when the motor was without load

    uint32_t GPIOB_InputData = GPIO_ReadInputData(GPIOB);




  //uint16_t newhallpos = ((GPIO_ReadInputData(GPIOD) & 0x7000) >> 12);
    uint16_t newhallpos = ((GPIOB_InputData & 0x0030) >> 4) | ((GPIOB_InputData & 0x0001) << 2);

    GPIO_Write(GPIOD, (GPIO_ReadOutputData(GPIOD) & ~0x0007) | newhallpos);

  static uint16_t hallpos;
  //static uint16_t lasthallpos;

  if (newhallpos == hallpos) return;
  //lasthallpos = hallpos;

  hallpos = newhallpos;
  /*uint16_t step = hallpos;

  if (step == 1)
    {
      // Next step: Step 2 Configuration --------------------------------------
      //  Channel3 configuration
      TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);

      //  Channel1 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_PWM1);
      TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
      TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);

      //*  Channel2 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_PWM1 );
      TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Enable);
      step++;
    }
    else if (step == 2)
    {
      /* Next step: Step 3 Configuration --------------------------------------
      /*  Channel2 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_PWM1);
      TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Enable);

      /*  Channel3 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_PWM1);
      TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
       TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);

      /*  Channel1 configuration
      TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);
      step++;
    }
    else if (step == 3)
    {
      /* Next step: Step 4 Configuration -------------------------------------- */
      /*  Channel3 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_PWM1);
      TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
      TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);

      /*  Channel2 configuration
      TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);

      /*  Channel1 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_PWM1);
      TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Enable);
      step++;
    }
    else if (step == 4)
    {
      /* Next step: Step 5 Configuration -------------------------------------- */
      /*  Channel3 configuration
      TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);

      /*  Channel1 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_PWM1);
      TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Enable);

      /*  Channel2 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_PWM1);
      TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
      TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
      step++;
    }
    else if (step == 5)
    {
      /* Next step: Step 6 Configuration -------------------------------------- */
      /*  Channel3 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_PWM1);
      TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Enable);

      /*  Channel1 configuration
      TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);

      /*  Channel2 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_PWM1);
      TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
      TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
      step++;
    }
    else
    {
      /* Next step: Step 1 Configuration --------------------------------------
      /*  Channel1 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_PWM1);
      TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);
      TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);

      /*  Channel3 configuration
      TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_PWM1);
      TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Enable);

      /*  Channel2 configuration
      TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Disable);
      TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
      step = 1;
    }
*/


  // this is only for motor direction forward

  bool BH1 = BLDC_BRIDGE_STATE_VORWARD[hallpos][0];
  bool BL1 = BLDC_BRIDGE_STATE_VORWARD[hallpos][1];

  bool BH2 = BLDC_BRIDGE_STATE_VORWARD[hallpos][2];
  bool BL2 = BLDC_BRIDGE_STATE_VORWARD[hallpos][3];

  bool BH3 = BLDC_BRIDGE_STATE_VORWARD[hallpos][4];
  bool BL3 = BLDC_BRIDGE_STATE_VORWARD[hallpos][5];

  // **** this is with active freewheeling ****

  // Bridge FETs for Motor Phase U
  if (BH1) {

    // PWM at low side FET of bridge U
    // active freewheeling at high side FET of bridge U
    // if low side FET is in PWM off mode then the hide side FET
    // is ON for active freewheeling. This mode needs correct definition
    // of dead time otherwise we have shoot-through problems

    TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_OCMode_PWM1);

    TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Enable);

    TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Enable);

    GPIO_SetBits(GPIOD, GPIO_Pin_15);//Blau

  } else {

    // High side FET: OFF
    TIM_CCxCmd(TIM1, TIM_Channel_1, TIM_CCx_Disable);       //Seite 411, 412 reference manual
    GPIO_ResetBits(GPIOD, GPIO_Pin_15);//Blau

    if (BL1){

     // Low side FET: ON
     TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_ForcedAction_Active);

      TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Enable);

      GPIO_SetBits(GPIOD, GPIO_Pin_12); //Grün

    } else {
        TIM_SelectOCxM(TIM1, TIM_Channel_1, TIM_ForcedAction_InActive);

      // Low side FET: OFF
      TIM_CCxNCmd(TIM1, TIM_Channel_1, TIM_CCxN_Disable);
      GPIO_ResetBits(GPIOD, GPIO_Pin_12);   //Grün

    }

  }

  // Bridge FETs for Motor Phase V

  if (BH2) {
    TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_OCMode_PWM1);
    TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Enable);
    TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Enable);
  } else {
    TIM_CCxCmd(TIM1, TIM_Channel_2, TIM_CCx_Disable);

    if (BL2){
      TIM_SelectOCxM(TIM1, TIM_Channel_2, TIM_ForcedAction_Active);
      TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Enable);
    } else {
      TIM_CCxNCmd(TIM1, TIM_Channel_2, TIM_CCxN_Disable);
    }
  }

  // Bridge FETs for Motor Phase W

  if (BH3) {
    TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_OCMode_PWM1);
    TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Enable);
    TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Enable);
  } else {
    TIM_CCxCmd(TIM1, TIM_Channel_3, TIM_CCx_Disable);

  if (BL3){
      TIM_SelectOCxM(TIM1, TIM_Channel_3, TIM_ForcedAction_Active);
      TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Enable);
    } else {
      TIM_CCxNCmd(TIM1, TIM_Channel_3, TIM_CCxN_Disable);
    }
  }
}

